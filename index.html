<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Awesome Scratch</title>
    <link rel="stylesheet" href="./css/index.css">
</head>

<script src="https://s0.babyfs.cn/op/f/1/f14a6b01c1264e159e5dc678071a39ea/setScreenHoriz.js"></script>

<body>
    <!-- <script src="../scratch-vm/dist/web/scratch-vm.js"></script>
    <script src="../scratch-storage/dist/web/scratch-storage.js"></script>
    <script src="../scratch-svg-renderer/dist/web/scratch-svg-renderer.js"></script>
    <script src="../scratch-render/dist/web/scratch-render.js"></script> -->
    <!-- <script src="../scratch-audio/dist.js"></script> -->
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="./script/scratch-vm.js"></script>
    <script src="./script/scratch-storage.js"></script>
    <script src="./script/scratch-svg-renderer.js"></script>
    <script src="./script/scratch-render.js"></script>
    <script src="./script/scratch-audio.js"></script>

    <canvas id="ocanvas"></canvas>
    <input type="file" id="file" name="file" style="display: none;">
    <label id="file-label" for="file">Select other files from filesystem</label>

    <a class=dropdown>choosing an example
        <select id="select">
            <option>
            <option value=0>Icanhelp copy
            <option value=1>Party dodge! (contest entry) (1)
            <option value=2>Programmable Drum Kit (1)
            <option value=3>DIY Gobo Plush ★ Scratch Day 2019
            <option value=4>Summer Waves _ Spiral(2)
        </select>
    </a>

    <div id="detec">
        <p id="J_detectRes"></p>
        <p id="J_detectData"></p>
        <p id="J_detectWH"></p>
    </div>

    <script>
        var canvasH, canvasW;

        // 判断横竖屏
        var utils = {
            debounce: function (func, delay) {
                var timer = null;
                return function () {
                    var context = this,
                        args = arguments;
                    clearTimeout(timer);
                    timer = setTimeout(function () {
                        func.apply(context, args);
                    }, delay);
                }
            }
        }

        var detectRes = document.getElementById('J_detectRes');
        var detectData = document.getElementById('J_detectData');
        var detectWH = document.getElementById('J_detectWH');

        function detectOrient() {
            var storage = localStorage; // 不一定要使用localStorage，其他存储数据的手段都可以
            var data = storage.getItem('J-recordOrientX');
            var cw = document.documentElement.clientWidth;

            var _Width = 0,
                _Height = 0;
            if (!data) {
                sw = window.screen.width;
                sh = window.screen.height;
                // 2.在某些机型（如华为P9）下出现 srceen.width/height 值交换，所以进行大小值比较判断
                _Width = sw < sh ? sw : sh;
                _Height = sw >= sh ? sw : sh;
                storage.setItem('J-recordOrientX', _Width + ',' + _Height);
            } else {
                var str = data.split(',');
                _Width = str[0];
                _Height = str[1];
            }

            if (cw == _Width) {
                // 竖屏
                detectRes.innerHTML = '检测结果是竖屏';
            }
            if (cw == _Height) {
                // 横屏
                detectRes.innerHTML = '检测结果是横屏';
            }


            detectData.innerHTML = 'clientWidth；' + document.documentElement.clientWidth + ';<br>' +
                'clientHeight；' + document.documentElement.clientHeight + ';<br>' +
                'screen.width：' + window.screen.width + ';<br>' +
                'screen.height：' + window.screen.height + ';';

            let standardRatio = 667 / 375;

            if (document.documentElement.clientWidth > document.documentElement.clientHeight) {
                canvasW = document.documentElement.clientWidth;
                canvasH = document.documentElement.clientHeight;
            } else {
                canvasW = document.documentElement.clientHeight;
                canvasH = document.documentElement.clientWidth;
            }

            let actualRatio = canvasW / canvasH;

            // 基于16:9基准调整
            if (actualRatio > standardRatio) {
                // canvasH = 375
                canvasW = (canvasH * standardRatio).toFixed(2)
            } else {
                // canvasW = 667
                canvasH = (canvasW / standardRatio).toFixed(2)
            }

            // console.log(canvasW, canvasH);
            detectWH.innerHTML = 'canvasW: ' + canvasW + ';<br>' +
                'canvasH: ' + canvasH;
        }

        // 3.函数去抖处理
        window.onresize = utils.debounce(detectOrient, 300);
        detectOrient();

        var oSel = document.getElementById('select');
        oSel.onchange = function () {
            let filename = ''
            const value = oSel.options[oSel.selectedIndex].value;
            switch (Number(value)) {
                case 0:
                    filename = 'Icanhelp copy'
                    break;
                case 1:
                    filename = 'Party dodge! (contest entry) (1)'
                    break;
                case 2:
                    filename = 'Programmable Drum Kit (1)'
                    break;
                case 3:
                    filename = 'DIY Gobo Plush ★ Scratch Day 2019'
                    break;
                case 4:
                    // case 4 是直接从scratch官方扒下来的 分辨率方面有问题
                    filename = 'Summer Waves _ Spiral(2)'
                    break;

            }
            let path = `./sb3/${filename}.sb3`
            downloadScratchFile(path)
        };

        function downloadScratchFile(path = './sb3/Icanhelp.sb3') {
            axios
                .get(path, {
                    responseType: 'blob'
                })
                .then((res) => {
                    console.log(res);
                    let reader = new FileReader();
                    reader.onload = () => {
                        vm.start();
                        vm.loadProject(reader.result)
                            .then(() => {
                                vm.greenFlag(); // 执行程序
                            });
                    };
                    reader.readAsArrayBuffer(res.data);
                })
        }

        // These variables are going to be available in the "window global" intentionally.
        // Allows you easy access to debug with `vm.greenFlag()` etc.
        window.devicePixelRatio = 3;
        const dragThreshold = 3;

        const state = {
            mouseDown: false,
            mouseDownTimeoutId: null,
            mouseDownPosition: null,
            isDragging: false,
            dragOffset: null,
            dragId: null
        };

        var canvas = document.getElementById('ocanvas');
        canvas.style.width = canvasW + 'px';
        canvas.style.height = canvasH + 'px';
        canvas.style.marginLeft = -canvasW / 2 + 'px';
        canvas.style.marginTop = -canvasH / 2 + 'px';
        var render = new ScratchRender(canvas);
        var vm = new VirtualMachine();
        var storage = new ScratchStorage();
        var audioEngine = new AudioEngine();

        vm.attachStorage(storage);
        vm.attachRenderer(render);
        vm.attachAudioEngine(audioEngine);
        vm.attachV2SVGAdapter(new ScratchSVGRenderer.SVGRenderer());
        vm.attachV2BitmapAdapter(new ScratchSVGRenderer.BitmapAdapter());

        document.getElementById('file').addEventListener('change', e => {
            let reader = new FileReader();
            let thisFileInput = e.target;
            reader.onload = () => {
                vm.start();
                vm.loadProject(reader.result)
                    .then(() => {
                        vm.greenFlag(); // 执行程序

                    });
            };
            reader.readAsArrayBuffer(thisFileInput.files[0]);
        });

        function getEventXY(e) {
            if (e.touches && e.touches[0]) {
                return {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            } else if (e.changedTouches && e.changedTouches[0]) {
                return {
                    x: e.changedTouches[0].clientX,
                    y: e.changedTouches[0].clientY
                };
            }
            return {
                x: e.clientX,
                y: e.clientY
            };
        }

        function attachMouseEvents(canvas) {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchmove', onMouseMove);
            document.addEventListener('touchend', onMouseUp);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('touchstart', onMouseDown);
        }

        function onMouseMove(e) {
            const {
                x,
                y
            } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];

            if (state.mouseDown && !state.isDragging) {
                const distanceFromMouseDown = Math.sqrt(
                    Math.pow(mousePosition[0] - state.mouseDownPosition[0], 2) +
                    Math.pow(mousePosition[1] - state.mouseDownPosition[1], 2)
                );
                if (distanceFromMouseDown > dragThreshold) {
                    cancelMouseDownTimeout();
                    onStartDrag(...state.mouseDownPosition);
                }
            }

            if (state.mouseDown && state.isDragging) {
                // Editor drag style only updates the drag canvas, does full update at the end of drag
                // Non-editor drag style just updates the sprite continuously.
                const spritePosition = getScratchCoords(mousePosition[0], mousePosition[1]);
                vm.postSpriteInfo({
                    x: spritePosition[0] + state.dragOffset[0],
                    y: -(spritePosition[1] + state.dragOffset[1]),
                    force: true
                });
            }
            const coordinates = {
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height
            };
            vm.postIOData('mouse', coordinates);
        }

        function onMouseUp(e) {
            const {
                x,
                y
            } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];
            cancelMouseDownTimeout();
            state['mouseDown'] = false;
            state['mouseDownPosition'] = null;
            const data = {
                isDown: false,
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height,
                wasDragged: state.isDragging
            };
            if (state.isDragging) {
                onStopDrag(mousePosition[0], mousePosition[1]);
            }
            vm.postIOData('mouse', data);
        }

        function onMouseDown(e) {
            const {
                x,
                y
            } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];
            if (e.button === 0 || (window.TouchEvent && e instanceof TouchEvent)) {
                state['mouseDown'] = true;
                state['mouseDownPosition'] = mousePosition;
                // state['mouseDownTimeoutId'] = setTimeout(onStartDrag(mousePosition[0], mousePosition[1]), 400)
            }
            const data = {
                isDown: true,
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height
            };

            vm.postIOData('mouse', data);
            if (e.preventDefault) {
                // Prevent default to prevent touch from dragging page
                e.preventDefault();
                // But we do want any active input to be blurred
                if (document.activeElement && document.activeElement.blur) {
                    document.activeElement.blur();
                }
            }
        }

        function cancelMouseDownTimeout() {
            if (state.mouseDownTimeoutId !== null) {
                clearTimeout(state.mouseDownTimeoutId);
            }
            state['mouseDownTimeoutId'] = null;
        }

        function onStartDrag(x, y) {
            if (state.dragId) return;
            const drawableId = render.pick(x, y);
            if (drawableId === null) return;
            const targetId = vm.getTargetIdForDrawableId(drawableId);
            if (targetId === null) return;

            const target = vm.runtime.getTargetById(targetId);

            // Do not start drag unless in editor drag mode or target is draggable
            if (!target.draggable) return;

            // Dragging always brings the target to the front
            target.goToFront();

            // Extract the drawable art
            const drawableData = render.extractDrawable(drawableId, x, y);

            vm.startDrag(targetId);

            state['isDragging'] = true;
            state['dragId'] = targetId;
            state['dragOffset'] = drawableData.scratchOffset;
        }

        function onStopDrag(mouseX, mouseY) {
            const dragId = state.dragId;
            const commonStopDragActions = () => {
                vm.stopDrag(dragId);
                state['isDragging'] = false;
                state['dragOffset'] = null;
                state['dragId'] = null;
            };
            commonStopDragActions();
        }

        function getScratchCoords(x, y) {
            const nativeSize = render.getNativeSize();
            const rect = canvas.getBoundingClientRect();
            return [
                (nativeSize[0] / rect.width) * (x - (rect.width / 2)),
                (nativeSize[1] / rect.height) * (y - (rect.height / 2))
            ];
        }

        downloadScratchFile();
        attachMouseEvents(canvas);
    </script>

</body>

</html>