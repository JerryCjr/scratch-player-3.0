<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Awesome Scratch</title>
    <link rel="stylesheet" href="./css/index.css">
</head>

<!-- <script src="./script/babyfsJsbridge.min.js"></script> -->
<script src="./script/axios.min.js"></script>
<script src="./script/scratch-storage.js"></script>
<script src="./script/scratch-audio.js"></script>
<script src="./script/vconsole.min.js"></script>
<script src="./script/scratch-vm.js"></script>
<script src="./script/util.js"></script>

<body>
    <!-- loading -->
    <div id='j_page-loading' class='m-actloading' style='background-color:rgba(4, 18, 34, 1)'>
        <div class='loading' style='color:rgba(255, 255, 255, 1)'>
            <div class='bars'>
                <span class='loading-bar b1' style='background-color:rgba(255, 255, 255, 1)'></span>
                <span class='loading-bar b2' style='background-color:rgba(255, 255, 255, 1)'></span>
                <span class='loading-bar b3' style='background-color:rgba(255, 255, 255, 1)'></span>
                <span class='loading-bar b4' style='background-color:rgba(255, 255, 255, 1)'></span>
                <span class='loading-bar b5' style='background-color:rgba(255, 255, 255, 1)'></span>
                <span class='loading-bar b6' style='background-color:rgba(255, 255, 255, 1)'></span>
                <span class='loading-bar b7' style='background-color:rgba(255, 255, 255, 1)'></span>
            </div>
            <span class='loading-tip'>loading<i class='dots d1'>.</i><i class='dots d2'>.</i><i class='dots d3'>.</i></span>
        </div>
    </div>
    <!-- canvas -->
    <canvas id="ocanvas"></canvas>
    <!-- render 引擎 -->
    <script src="./script/scratch-svg-renderer.js"></script>
    <script src="./script/scratch-render.js"></script>

    <div id="debug-area">
        <div id="detec">
            <p id="J_detectRes"></p>
            <p id="J_detectData"></p>
            <p id="J_detectWH"></p>
        </div>
    </div>

    <script>
        "use strict";
        window.__bbfs_scratch = {}; // 适应业务的全局实例
        window.__bbfs_scratch['debug'] = true;
        // const bridge = window['babyfs-jsbridge'].default;
        // bridge.callHandler('setScreenHoriz');
        // debug 开关
        function switchDebug() {
            const debugDom = document.getElementById('debug-area');
            if (window.__bbfs_scratch['debug']) {
                debugDom.style.display = 'block';
                const vConsole = new VConsole(); // debug vconsole init
            } else {
                debugDom.style.display = 'none';
            }
        }
        switchDebug();

        window.devicePixelRatio = 3;
        detectOrient(); // 监测屏幕方向
        window.onresize = debounce(detectOrient, 300);
        const loading = document.getElementById('j_page-loading');
        // loading显示隐藏开关切换
        function switchLoading(_sw) {
            if (_sw) {
                loading.style.display = 'block';
            } else {
                loading.style.display = 'none';
            }
        }
        // 切换项目前
        function beforeSwitchProject() {
            switchLoading(true);
            vm.stopAll();
            vm.clear();
        }
        // 切换项目后
        function afterSwitchProject() {
            switchLoading(false);
            vm.greenFlag(); // 执行程序
        }
        switchLoading(true);
        const canvas = document.getElementById('ocanvas');
        const oSel = document.getElementById('select');
        const oFile = document.getElementById('file');
        const dragThreshold = 3;
        const state = {
            mouseDown: false,
            mouseDownTimeoutId: null,
            mouseDownPosition: null,
            isDragging: false,
            dragOffset: null,
            dragId: null
        };
        const render = new ScratchRender(canvas);
        const vm = new VirtualMachine();
        const storage = new ScratchStorage();
        const audioEngine = new AudioEngine();
        resizeCanvas(canvas, __bbfs_scratch['canvasW'], __bbfs_scratch['canvasH'])
        vm.attachStorage(storage);
        vm.attachRenderer(render);
        vm.attachAudioEngine(audioEngine);
        vm.attachV2SVGAdapter(new ScratchSVGRenderer.SVGRenderer());
        vm.attachV2BitmapAdapter(new ScratchSVGRenderer.BitmapAdapter());
        vm.runtime.on('PROJECT_START', (e) => {
            window.__bbfs_scratch['LOADED_PROJECT'] = +new Date();
            window.__bbfs_scratch['LOAD_PROJECT_DURATION'] = window.__bbfs_scratch['LOADED_PROJECT'] - window.__bbfs_scratch['LOAD_PROJECT'];
            window.__bbfs_scratch['WHOLE_DURATION'] = window.__bbfs_scratch['LOADED_PROJECT'] - window.__bbfs_scratch['LOAD'];
            // WINDOW.LOAD
            console.log('[LOAD]', window.__bbfs_scratch['LOAD']);
            console.log('[UNLOAD]', window.__bbfs_scratch['UNLOAD']);
            console.log('[LOAD_DURATION]', window.__bbfs_scratch['LOAD_DURATION']);
            // PROJECT
            console.log('[FETCH_SB3]', window.__bbfs_scratch['FETCH_SB3']);
            console.log('[FETCHED_SB3]', window.__bbfs_scratch['FETCHED_SB3']);
            console.log('[FETCH_SB3_DURATION]', window.__bbfs_scratch['FETCH_SB3_DURATION']);
            // LOAD SB3
            console.log('[LOAD_SB3]', window.__bbfs_scratch['LOAD_SB3']);
            console.log('[LOADED_SB3]', window.__bbfs_scratch['LOADED_SB3']);
            console.log('[LOAD_SB3_DURATION]', window.__bbfs_scratch['LOAD_SB3_DURATION']);
            // PROJECT
            console.log('[LOAD_PROJECT]', window.__bbfs_scratch['LOAD_PROJECT']);
            console.log('[LOADED_PROJECT]', window.__bbfs_scratch['LOADED_PROJECT']);
            console.log('[LOAD_PROJECT_DURATION]', window.__bbfs_scratch['LOAD_PROJECT_DURATION']);
            // DURATION
            window.__bbfs_scratch['LOAD_TO_FETCH_DURATION'] = window.__bbfs_scratch['FETCHED_SB3'] - window.__bbfs_scratch['LOAD'];
            window.__bbfs_scratch['SCRIPT_START']
            console.log('[LOAD_TO_FETCH_DURATION]', window.__bbfs_scratch['LOAD_TO_FETCH_DURATION']);
            console.log('[WHOLE_DURATION]', window.__bbfs_scratch['WHOLE_DURATION']);
            console.log('[SCRIPT_TO_PROJECT_DURATION]', window.__bbfs_scratch['SCRIPT_TO_PROJECT_DURATION']);
            // console.log(window.performance);
            // console.log('[MEMORY]', window.performance['memory']);
            // console.log('[TIMING]', window.performance['timing']);
        })

        // 绑定鼠标事件
        function attachMouseEvents(canvas) {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchmove', onMouseMove);
            document.addEventListener('touchend', onMouseUp);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('touchstart', onMouseDown);
        }

        function detachMouseEvents(canvas) {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.removeEventListener('touchmove', onMouseMove);
            document.removeEventListener('touchend', onMouseUp);
            canvas.removeEventListener('mousedown', onMouseDown);
            canvas.removeEventListener('touchstart', onMouseDown);
        }

        function onMouseMove(e) {
            const { x, y } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];

            if (state.mouseDown && !state.isDragging) {
                const distanceFromMouseDown = Math.sqrt(
                    Math.pow(mousePosition[0] - state.mouseDownPosition[0], 2) +
                    Math.pow(mousePosition[1] - state.mouseDownPosition[1], 2)
                );
                if (distanceFromMouseDown > dragThreshold) {
                    cancelMouseDownTimeout();
                    onStartDrag(...state.mouseDownPosition);
                }
            }

            if (state.mouseDown && state.isDragging) {
                // Editor drag style only updates the drag canvas, does full update at the end of drag
                // Non-editor drag style just updates the sprite continuously.
                const spritePosition = getScratchCoords(mousePosition[0], mousePosition[1]);
                vm.postSpriteInfo({
                    x: spritePosition[0] + state.dragOffset[0],
                    y: -(spritePosition[1] + state.dragOffset[1]),
                    force: true
                });
            }
            const coordinates = {
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height
            };
            vm.postIOData('mouse', coordinates);
        }

        function onMouseUp(e) {
            const { x, y } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];
            cancelMouseDownTimeout();
            state['mouseDown'] = false;
            state['mouseDownPosition'] = null;
            const data = {
                isDown: false,
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height,
                wasDragged: state.isDragging
            };
            if (state.isDragging) {
                onStopDrag(mousePosition[0], mousePosition[1]);
            }
            vm.postIOData('mouse', data);
        }

        function onMouseDown(e) {
            const { x, y } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];
            if (e.button === 0 || (window.TouchEvent && e instanceof TouchEvent)) {
                state['mouseDown'] = true;
                state['mouseDownPosition'] = mousePosition;
                // state['mouseDownTimeoutId'] = setTimeout(onStartDrag(mousePosition[0], mousePosition[1]), 400)
            }
            const data = {
                isDown: true,
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height
            };

            vm.postIOData('mouse', data);
            if (e.preventDefault) {
                // Prevent default to prevent touch from dragging page
                e.preventDefault();
                // But we do want any active input to be blurred
                if (document.activeElement && document.activeElement.blur) {
                    document.activeElement.blur();
                }
            }
        }

        function cancelMouseDownTimeout() {
            if (state.mouseDownTimeoutId !== null) {
                clearTimeout(state.mouseDownTimeoutId);
            }
            state['mouseDownTimeoutId'] = null;
        }

        function onStartDrag(x, y) {
            if (state.dragId) return;
            const drawableId = render.pick(x, y);
            if (drawableId === null) return;
            const targetId = vm.getTargetIdForDrawableId(drawableId);
            if (targetId === null) return;

            const target = vm.runtime.getTargetById(targetId);

            // Do not start drag unless in editor drag mode or target is draggable
            if (!target.draggable) return;

            // Dragging always brings the target to the front
            target.goToFront();

            // Extract the drawable art
            const drawableData = render.extractDrawable(drawableId, x, y);

            vm.startDrag(targetId);

            state['isDragging'] = true;
            state['dragId'] = targetId;
            state['dragOffset'] = drawableData.scratchOffset;
        }

        function onStopDrag(mouseX, mouseY) {
            const dragId = state.dragId;
            const commonStopDragActions = () => {
                vm.stopDrag(dragId);
                state['isDragging'] = false;
                state['dragOffset'] = null;
                state['dragId'] = null;
            };
            commonStopDragActions();
        }

        function getScratchCoords(x, y) {
            const nativeSize = render.getNativeSize();
            const rect = canvas.getBoundingClientRect();
            return [
                (nativeSize[0] / rect.width) * (x - (rect.width / 2)),
                (nativeSize[1] / rect.height) * (y - (rect.height / 2))
            ];
        }

        // 本地读取sb*文件(sb3)
        function readFromSb(targert) {
            window.__bbfs_scratch['LOAD_SB3'] = +new Date();
            const reader = new FileReader();
            reader.onload = () => {
                console.log(reader.result);
                window.__bbfs_scratch['LOADED_SB3'] = +new Date();
                window.__bbfs_scratch['LOAD_SB3_DURATION'] = window.__bbfs_scratch.LOADED_SB3 - window.__bbfs_scratch.LOAD_SB3;
                vm.start();
                window.__bbfs_scratch['LOAD_PROJECT'] = +new Date();
                vm.loadProject(reader.result)
                    .then(() => {
                        afterSwitchProject();
                    });
            };
            reader.readAsArrayBuffer(targert);
        }

        // fetch scratch files(sb3)
        function fetchScratchFile(path = getQueryString('file')) {
            window.__bbfs_scratch['FETCH_SB3'] = +new Date();
            console.log('[current sb3 path is: ]', path);
            beforeSwitchProject();
            axios.get(path, {
                responseType: 'blob'
            })
                .then((res) => {
                    console.log(res);
                    window.__bbfs_scratch['FETCHED_SB3'] = +new Date();
                    window.__bbfs_scratch['FETCH_SB3_DURATION'] = window.__bbfs_scratch['FETCHED_SB3'] - window.__bbfs_scratch['FETCH_SB3'];
                    readFromSb(res.data)
                })
        }

        window.addEventListener('load', function () {
            window.__bbfs_scratch['LOAD'] = +new Date();
            attachMouseEvents(canvas);
            fetchScratchFile();
        })

        window.addEventListener('unLoad', function () {
            window.__bbfs_scratch['UNLOAD'] = +new Date();
            window.__bbfs_scratch['LOAD_DURATION'] = window.__bbfs_scratch['UNLOAD'] - window.__bbfs_scratch['LOAD'];
            window.__bbfs_scratch = null;
            detachMouseEvents(canvas);
        })

    </script>
</body>

</html>