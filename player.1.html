<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Awesome Scratch</title>
    <link rel="stylesheet" href="./css/index.css">
</head>

<script src="https://s0.babyfs.cn/op/f/1/f14a6b01c1264e159e5dc678071a39ea/setScreenHoriz.js"></script>

<body>
    <canvas id="ocanvas"></canvas>

    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="./script/scratch-vm.js"></script>
    <script src="./script/scratch-storage.js"></script>
    <script src="./script/scratch-svg-renderer.js"></script>
    <script src="./script/scratch-render.js"></script>
    <script src="./script/scratch-audio.js"></script>

    <input type="file" id="file" name="file" style="display: none;">
    <label id="file-label" for="file">Select other files from filesystem</label>
    <a class=dropdown>Select other files from local
        <select id="select">
            <option>
            <option value=0>Icanhelp.sb3
            <option value=1>Party dodge! (contest entry) (1)
            <option value=2>Programmable Drum Kit (1)
            <option value=3>DIY Gobo Plush ★ Scratch Day 2019
            <option value=4>Summer Waves _ Spiral(2)
            <option value=5>iphonex
        </select>
    </a>

    <div id="detec">
        <p id="J_detectRes"></p>
        <p id="J_detectData"></p>
        <p id="J_detectWH"></p>
    </div>

    <script>
        function getQueryString(name) {
            var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
            var r = window.location.search.substr(1).match(reg);
            if (r != null) return unescape(r[2]); return null;
        }

        let canvasH = getQueryString('y'), canvasW = getQueryString('x');
        const detectWH = document.getElementById('J_detectWH');
        canvasW = (canvasH / 9 * 19.5).toFixed(2);
        detectWH.innerHTML = 'canvasW: ' + canvasW + ';<br>' + 'canvasH: ' + canvasH;
        const oSel = document.getElementById('select');
        const oFile = document.getElementById('file');
        window.devicePixelRatio = 3;
        const dragThreshold = 3;
        const state = {
            mouseDown: false,
            mouseDownTimeoutId: null,
            mouseDownPosition: null,
            isDragging: false,
            dragOffset: null,
            dragId: null
        };
        const canvas = document.getElementById('ocanvas');
        const render = new ScratchRender(canvas);
        const vm = new VirtualMachine();
        const storage = new ScratchStorage();
        const audioEngine = new AudioEngine();

        function downloadScratchFile(path = getQueryString('file')) {
            console.log(path);
            axios.get(path, {
                responseType: 'blob'
            })
                .then((res) => {
                    console.log(res);
                    let reader = new FileReader();
                    reader.onload = () => {
                        vm.start();
                        vm.loadProject(reader.result)
                            .then(() => {
                                vm.greenFlag(); // 执行程序
                            });
                    };
                    reader.readAsArrayBuffer(res.data);
                })
        }

        function resizeCanvas(_w, _h) {
            canvas.style.width = _w + 'px';
            canvas.style.height = _h + 'px';
            canvas.style.marginLeft = - _w / 2 + 'px';
            canvas.style.marginTop = - _h / 2 + 'px';
        }

        function getEventXY(e) {
            if (e.touches && e.touches[0]) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.changedTouches && e.changedTouches[0]) {
                return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function attachMouseEvents(canvas) {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchmove', onMouseMove);
            document.addEventListener('touchend', onMouseUp);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('touchstart', onMouseDown);
        }

        function onMouseMove(e) {
            const { x, y } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];

            if (state.mouseDown && !state.isDragging) {
                const distanceFromMouseDown = Math.sqrt(
                    Math.pow(mousePosition[0] - state.mouseDownPosition[0], 2) +
                    Math.pow(mousePosition[1] - state.mouseDownPosition[1], 2)
                );
                if (distanceFromMouseDown > dragThreshold) {
                    cancelMouseDownTimeout();
                    onStartDrag(...state.mouseDownPosition);
                }
            }

            if (state.mouseDown && state.isDragging) {
                // Editor drag style only updates the drag canvas, does full update at the end of drag
                // Non-editor drag style just updates the sprite continuously.
                const spritePosition = getScratchCoords(mousePosition[0], mousePosition[1]);
                vm.postSpriteInfo({
                    x: spritePosition[0] + state.dragOffset[0],
                    y: -(spritePosition[1] + state.dragOffset[1]),
                    force: true
                });
            }
            const coordinates = {
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height
            };
            vm.postIOData('mouse', coordinates);
        }

        function onMouseUp(e) {
            const { x, y } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];
            cancelMouseDownTimeout();
            state['mouseDown'] = false;
            state['mouseDownPosition'] = null;
            const data = {
                isDown: false,
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height,
                wasDragged: state.isDragging
            };
            if (state.isDragging) {
                onStopDrag(mousePosition[0], mousePosition[1]);
            }
            vm.postIOData('mouse', data);
        }

        function onMouseDown(e) {
            const { x, y } = getEventXY(e);
            const rect = canvas.getBoundingClientRect();
            const mousePosition = [x - rect.left, y - rect.top];
            if (e.button === 0 || (window.TouchEvent && e instanceof TouchEvent)) {
                state['mouseDown'] = true;
                state['mouseDownPosition'] = mousePosition;
                // state['mouseDownTimeoutId'] = setTimeout(onStartDrag(mousePosition[0], mousePosition[1]), 400)
            }
            const data = {
                isDown: true,
                x: mousePosition[0],
                y: mousePosition[1],
                canvasWidth: rect.width,
                canvasHeight: rect.height
            };

            vm.postIOData('mouse', data);
            if (e.preventDefault) {
                // Prevent default to prevent touch from dragging page
                e.preventDefault();
                // But we do want any active input to be blurred
                if (document.activeElement && document.activeElement.blur) {
                    document.activeElement.blur();
                }
            }
        }

        function cancelMouseDownTimeout() {
            if (state.mouseDownTimeoutId !== null) {
                clearTimeout(state.mouseDownTimeoutId);
            }
            state['mouseDownTimeoutId'] = null;
        }

        function onStartDrag(x, y) {
            if (state.dragId) return;
            const drawableId = render.pick(x, y);
            if (drawableId === null) return;
            const targetId = vm.getTargetIdForDrawableId(drawableId);
            if (targetId === null) return;

            const target = vm.runtime.getTargetById(targetId);

            // Do not start drag unless in editor drag mode or target is draggable
            if (!target.draggable) return;

            // Dragging always brings the target to the front
            target.goToFront();

            // Extract the drawable art
            const drawableData = render.extractDrawable(drawableId, x, y);

            vm.startDrag(targetId);

            state['isDragging'] = true;
            state['dragId'] = targetId;
            state['dragOffset'] = drawableData.scratchOffset;
        }

        function onStopDrag(mouseX, mouseY) {
            const dragId = state.dragId;
            const commonStopDragActions = () => {
                vm.stopDrag(dragId);
                state['isDragging'] = false;
                state['dragOffset'] = null;
                state['dragId'] = null;
            };
            commonStopDragActions();
        }

        function getScratchCoords(x, y) {
            const nativeSize = render.getNativeSize();
            const rect = canvas.getBoundingClientRect();
            return [
                (nativeSize[0] / rect.width) * (x - (rect.width / 2)),
                (nativeSize[1] / rect.height) * (y - (rect.height / 2))
            ];
        }

        oSel.onchange = function () {
            let filename = ''
            const value = oSel.options[oSel.selectedIndex].value;
            switch (Number(value)) {
                case 0:
                    filename = 'Icanhelp'
                    break;
                case 1:
                    filename = 'Party dodge! (contest entry) (1)'
                    break;
                case 2:
                    filename = 'Programmable Drum Kit (1)'
                    break;
                case 3:
                    filename = 'DIY Gobo Plush ★ Scratch Day 2019'
                    break;
                case 4:
                    filename = 'Summer Waves _ Spiral(2)'
                    break;
                case 5:
                    filename = 'iphonex'
                    break;

            }
            const path = `./sb3/${filename}.sb3`
            downloadScratchFile(path)
        };

        oFile.addEventListener('change', e => {
            let reader = new FileReader();
            let thisFileInput = e.target;
            reader.onload = () => {
                vm.start();
                vm.loadProject(reader.result)
                    .then(() => {
                        vm.greenFlag(); // 执行程序
                    });
            };
            reader.readAsArrayBuffer(thisFileInput.files[0]);
        });

        resizeCanvas(canvasW, canvasH)
        vm.attachStorage(storage);
        vm.attachRenderer(render);
        vm.attachAudioEngine(audioEngine);
        vm.attachV2SVGAdapter(new ScratchSVGRenderer.SVGRenderer());
        vm.attachV2BitmapAdapter(new ScratchSVGRenderer.BitmapAdapter());
        downloadScratchFile();
        attachMouseEvents(canvas);

    </script>

</body>

</html>